/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
package [%=_packageName%].handler;

import java.util.Optional;
import java.util.UUID;
import java.util.function.Function;

import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CompoundCommand;
import org.eclipse.emf.edit.command.AddCommand;
import org.eclipse.emf.edit.command.SetCommand;
import org.eclipse.emf.edit.domain.EditingDomain;
import [%=_packageName%].[%=_metamodelName.firstToUpperCase()%]ModelTypes;
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=_metamodelPrefix%]Factory;
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=_metamodelPrefix%]Package;
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=createEdgeHandler.elementName%];
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=_root%];
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=_sourceType%];
[%if(_sourceType != _targetType){%]
import [%=_metamodelPackageName%].[%=_metamodelPrefix.toLowerCase()%].[%=_targetType%];
[%}%]
import org.eclipse.glsp.graph.GraphPackage;
import org.eclipse.glsp.server.emf.EMFCreateOperationHandler;
import org.eclipse.glsp.server.emf.EMFIdGenerator;
import org.eclipse.glsp.server.emf.notation.EMFNotationModelState;
import org.eclipse.glsp.server.operations.CreateEdgeOperation;

import com.google.inject.Inject;


public class Create[%=createEdgeHandler.elementName%]EdgeHandler extends EMFCreateOperationHandler<CreateEdgeOperation> {

	@Inject
	protected EMFNotationModelState modelState;
	
    @Inject
    protected EMFIdGenerator idGenerator;

    public Create[%=createEdgeHandler.elementName%]EdgeHandler() {
        super([%=_metamodelName.firstToUpperCase()%]ModelTypes.[%=createEdgeHandler.elementName.toUpperCase()%]);
    }

    public Create[%=createEdgeHandler.elementName%]EdgeHandler(String type) {
        super(type);
    }


    @Override
    public String getLabel() { return "[%=createEdgeHandler.elementName%]"; }

    @Override
    public Optional<Command> createCommand(CreateEdgeOperation operation) {
        [%=createEdgeHandler.elementName%] new[%=createEdgeHandler.elementName%] = [%=_metamodelPrefix%]Factory.eINSTANCE.create[%=createEdgeHandler.elementName%]();
        //newArc.setId(UUID.randomUUID().toString());
        //setInitialName(newTransition);

        //setType(newArc);

        String sourceId = operation.getSourceElementId();
        String targetId = operation.getTargetElementId();

        [%=_sourceType%] source = modelState.getIndex().getEObject(sourceId, [%=_sourceType%].class).orElseThrow();
        [%=_targetType%] target = modelState.getIndex().getEObject(targetId, [%=_targetType%].class).orElseThrow();

        //Page page = (Page) (source.eContainer());

        return Optional.of(create[%=createEdgeHandler.elementName%](new[%=createEdgeHandler.elementName%], source, target));
    }

//    protected void setInitialName(final Transition transition) {
//        Function<Integer, String> nameProvider = i -> "New" + transition.eClass().getName() + i;
//        int edgeCounter = modelState.getIndex().getCounter(GraphPackage.Literals.GEDGE, nameProvider);
//        Name newName = PtnetFactory.eINSTANCE.createName();
//        newName.setText(nameProvider.apply(ArcCounter));
//        arc.setName(newName);
//    }

    protected Command create[%=createEdgeHandler.elementName%]([%=createEdgeHandler.elementName%] new[%=createEdgeHandler.elementName%], [%=_sourceType%] source, [%=_targetType%] target) {
    	[%=_root%] [%=_root.firstToLowerCase()%] = modelState.getSemanticModel([%=_root%].class).orElseThrow();
        EditingDomain editingDomain = modelState.getEditingDomain();

        //explicitly set the arcs to the nodes (source / target) so the operation is added to the command stack
        // and can be undone. Otherwise, the reference would not be removed from the nodes.

        Command [%=createEdgeHandler.elementName.firstToLowerCase()%]Command = AddCommand.create(editingDomain, [%=_root.firstToLowerCase()%],
            [%=_metamodelPrefix%]Package.Literals.[%=_root.charAt(0)%][%for (i in Sequence{1.._root.length()-1}){%][%if(_root.substring(i,i+1).matches("[A-Z]")){%]_[%}%][%=_root.substring(i,i+1).toUpperCase()%][%}%]__[%=createEdgeHandler.referenceName.toUpperCase()%], new[%=createEdgeHandler.elementName%]);

        Command setSource = SetCommand.create(editingDomain, new[%=createEdgeHandler.elementName%],
        	[%=_metamodelPrefix%]Package.Literals.[%=createEdgeHandler.elementName.toUpperCase()%]__[%=_sourceReference.toUpperCase()%], source);

        Command setTarget = SetCommand.create(editingDomain, new[%=createEdgeHandler.elementName%],
        	[%=_metamodelPrefix%]Package.Literals.[%=createEdgeHandler.elementName.toUpperCase()%]__[%=_targetReference.toUpperCase()%], target);

        CompoundCommand compoundCommand = new CompoundCommand();

        compoundCommand.append([%=createEdgeHandler.elementName.firstToLowerCase()%]Command);
        compoundCommand.append(setSource);
        compoundCommand.append(setTarget);

        return compoundCommand;
    }

    //protected void setType(Arc arc){
        //empty because normal arcs do not have a type attribute in DiNeROS
        //used as template method for subclasses (inhibitor, read)
    //}

}
