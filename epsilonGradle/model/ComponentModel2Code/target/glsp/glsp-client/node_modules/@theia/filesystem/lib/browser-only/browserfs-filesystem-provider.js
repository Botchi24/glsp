"use strict";
// *****************************************************************************
// Copyright (C) 2023 EclipseSource and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/node/diskFileSystemProvider.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserFSFileSystemProvider = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-null/no-null */
const inversify_1 = require("@theia/core/shared/inversify");
const files_1 = require("../common/files");
const core_1 = require("@theia/core");
const browserfs_1 = require("browserfs");
const path_1 = require("path");
const promise_util_1 = require("@theia/core/lib/common/promise-util");
const browserfs_filesystem_initialization_1 = require("./browserfs-filesystem-initialization");
// adapted from DiskFileSystemProvider
let BrowserFSFileSystemProvider = class BrowserFSFileSystemProvider {
    constructor(initialization) {
        this.initialization = initialization;
        this.capabilities = 2 /* FileReadWrite */;
        this.onDidChangeCapabilities = core_1.Event.None;
        this.onDidChangeFile = core_1.Event.None;
        this.onFileWatchError = core_1.Event.None;
        this.mapHandleToPos = new Map();
        this.writeHandles = new Set();
        this.canFlush = true;
        const init = async () => {
            this.mountableFS = await initialization.createMountableFileSystem();
            this.fs = (0, browserfs_1.BFSRequire)('fs');
            await initialization.initializeFS(this.fs, new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'initialized') {
                        return Promise.resolve(true);
                    }
                    return Reflect.get(target, prop, receiver);
                }
            }));
            return true;
        };
        this.initialized = init();
    }
    async mount(mountPoint, fs) {
        await this.initialized;
        this.mountableFS.mount(mountPoint, fs);
    }
    ;
    watch(_resource, _opts) {
        return core_1.Disposable.NULL;
    }
    async stat(resource) {
        await this.initialized;
        const path = this.toFilePath(resource);
        let stats;
        try {
            stats = await this.promisify(this.fs.stat)(path);
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
        if (stats === undefined) {
            throw new Error(`Could not read file stat for resource '${path}'`);
        }
        return {
            type: this.toType(stats, /* symbolicLink */ undefined),
            ctime: stats.birthtime.getTime(),
            mtime: stats.mtime.getTime(),
            size: stats.size,
            // FIXME: missing mode, permissions
        };
    }
    async mkdir(resource) {
        await this.initialized;
        try {
            await this.promisify(this.fs.mkdir)(this.toFilePath(resource));
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
    }
    async readdir(resource) {
        await this.initialized;
        try {
            const children = await this.promisify(this.fs.readdir)(this.toFilePath(resource));
            const result = [];
            await Promise.all(children.map(async (child) => {
                try {
                    const stat = await this.stat(resource.resolve(child));
                    result.push([child, stat.type]);
                }
                catch (error) {
                    console.trace(error); // ignore errors for individual entries that can arise from permission denied
                }
            }));
            return result;
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
    }
    async delete(resource, _opts) {
        await this.initialized;
        // FIXME use options
        try {
            await this.promisify(this.fs.unlink)(this.toFilePath(resource));
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
    }
    async rename(from, to, opts) {
        await this.initialized;
        const fromFilePath = this.toFilePath(from);
        const toFilePath = this.toFilePath(to);
        if (fromFilePath === toFilePath) {
            return; // simulate node.js behaviour here and do a no-op if paths match
        }
        try {
            // assume FS is path case sensitive - correct?
            const targetExists = await this.promisify(this.fs.exists)(toFilePath);
            if (targetExists) {
                throw Error(`File '${toFilePath}' already exists.`);
            }
            if (fromFilePath === toFilePath) {
                return Promise.resolve();
            }
            await this.promisify(this.fs.rename)(fromFilePath, toFilePath);
            const stat = await this.promisify(this.fs.lstat)(toFilePath);
            if (stat.isDirectory() || stat.isSymbolicLink()) {
                return Promise.resolve(); // only for files
            }
            const fd = await this.promisify(open)(toFilePath, 'a');
            try {
                await this.promisify(this.fs.futimes)(fd, stat.atime, new Date());
            }
            catch (error) {
                // ignore
            }
            this.promisify(this.fs.close)(fd);
        }
        catch (error) {
            // rewrite some typical errors that can happen especially around symlinks
            // to something the user can better understand
            if (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {
                error = new Error(`Unable to move '${(0, path_1.basename)(fromFilePath)}' into '${(0, path_1.basename)((0, path_1.dirname)(toFilePath))}' (${error.toString()}).`);
            }
            throw this.toFileSystemProviderError(error);
        }
    }
    async copy(from, to, opts) {
        await this.initialized;
        throw new Error('Method not implemented.');
    }
    async readFile(resource) {
        await this.initialized;
        try {
            const filePath = this.toFilePath(resource);
            return await this.promisify(this.fs.readFile)(filePath);
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
    }
    async writeFile(resource, content, opts) {
        await this.initialized;
        let handle = undefined;
        try {
            const filePath = this.toFilePath(resource);
            // Validate target unless { create: true, overwrite: true }
            if (!opts.create || !opts.overwrite) {
                const fileExists = await this.promisify(this.fs.exists)(filePath);
                if (fileExists) {
                    if (!opts.overwrite) {
                        throw (0, files_1.createFileSystemProviderError)('File already exists', files_1.FileSystemProviderErrorCode.FileExists);
                    }
                }
                else {
                    if (!opts.create) {
                        throw (0, files_1.createFileSystemProviderError)('File does not exist', files_1.FileSystemProviderErrorCode.FileNotFound);
                    }
                }
            }
            // Open
            handle = await this.open(resource, { create: true });
            // Write content at once
            await this.write(handle, 0, content, 0, content.byteLength);
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
        finally {
            if (typeof handle === 'number') {
                await this.close(handle);
            }
        }
    }
    readFileStream(resource, opts, token) {
        throw new Error('Method not implemented.');
    }
    async open(resource, opts) {
        await this.initialized;
        try {
            const filePath = this.toFilePath(resource);
            let flags = undefined;
            if (opts.create) {
                // we take opts.create as a hint that the file is opened for writing
                // as such we use 'w' to truncate an existing or create the
                // file otherwise. we do not allow reading.
                if (!flags) {
                    flags = 'w';
                }
            }
            else {
                // otherwise we assume the file is opened for reading
                // as such we use 'r' to neither truncate, nor create
                // the file.
                flags = 'r';
            }
            const handle = await this.promisify(this.fs.open)(filePath, flags);
            // remember this handle to track file position of the handle
            // we init the position to 0 since the file descriptor was
            // just created and the position was not moved so far (see
            // also http://man7.org/linux/man-pages/man2/open.2.html -
            // "The file offset is set to the beginning of the file.")
            this.mapHandleToPos.set(handle, 0);
            // remember that this handle was used for writing
            if (opts.create) {
                this.writeHandles.add(handle);
            }
            return handle;
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
    }
    async close(fd) {
        await this.initialized;
        // remove this handle from map of positions
        this.mapHandleToPos.delete(fd);
        // if a handle is closed that was used for writing, ensure
        // to flush the contents to disk if possible.
        if (this.writeHandles.delete(fd) && this.canFlush) {
            try {
                await this.promisify(this.fs.fdatasync)(fd);
            }
            catch (error) {
                // In some exotic setups it is well possible that node fails to sync
                // In that case we disable flushing and log the error to our logger
                this.canFlush = false;
                console.error(error);
            }
        }
        await this.promisify(this.fs.close)(fd);
    }
    async read(fd, pos, data, offset, length) {
        await this.initialized;
        const normalizedPos = this.normalizePos(fd, pos);
        let bytesRead = null;
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const result = (await this.promisify(this.fs.read)(fd, data, offset, length, normalizedPos));
            if (typeof result === 'number') {
                bytesRead = result; // node.d.ts fail
            }
            else {
                bytesRead = result.bytesRead;
            }
            return bytesRead;
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
        finally {
            this.updatePos(fd, normalizedPos, bytesRead);
        }
    }
    async write(fd, pos, data, offset, length) {
        await this.initialized;
        // we know at this point that the file to write to is truncated and thus empty
        // if the write now fails, the file remains empty. as such we really try hard
        // to ensure the write succeeds by retrying up to three times.
        return (0, promise_util_1.retry)(() => this.doWrite(fd, pos, data, offset, length), 100 /* ms delay */, 3 /* retries */);
    }
    async doWrite(fd, pos, data, offset, length) {
        await this.initialized;
        const normalizedPos = this.normalizePos(fd, pos);
        let bytesWritten = null;
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const result = (await this.promisify(this.fs.write)(fd, data, offset, length, normalizedPos));
            if (typeof result === 'number') {
                bytesWritten = result; // node.d.ts fail
            }
            else {
                bytesWritten = result.bytesWritten;
            }
            return bytesWritten;
        }
        catch (error) {
            throw this.toFileSystemProviderError(error);
        }
        finally {
            this.updatePos(fd, normalizedPos, bytesWritten);
        }
    }
    normalizePos(fd, pos) {
        // when calling fs.read/write we try to avoid passing in the "pos" argument and
        // rather prefer to pass in "null" because this avoids an extra seek(pos)
        // call that in some cases can even fail (e.g. when opening a file over FTP -
        // see https://github.com/microsoft/vscode/issues/73884).
        //
        // as such, we compare the passed in position argument with our last known
        // position for the file descriptor and use "null" if they match.
        if (pos === this.mapHandleToPos.get(fd)) {
            return null;
        }
        return pos;
    }
    updatePos(fd, pos, bytesLength) {
        const lastKnownPos = this.mapHandleToPos.get(fd);
        if (typeof lastKnownPos === 'number') {
            // pos !== null signals that previously a position was used that is
            // not null. node.js documentation explains, that in this case
            // the internal file pointer is not moving and as such we do not move
            // our position pointer.
            //
            // Docs: "If position is null, data will be read from the current file position,
            // and the file position will be updated. If position is an integer, the file position
            // will remain unchanged."
            if (typeof pos === 'number') {
                // do not modify the position
            }
            else if (typeof bytesLength === 'number') {
                this.mapHandleToPos.set(fd, lastKnownPos + bytesLength);
            }
            else {
                this.mapHandleToPos.delete(fd);
            }
        }
    }
    async access(resource, mode) {
        await this.initialized;
        throw new Error('Method not implemented.');
    }
    async fsPath(resource) {
        await this.initialized;
        throw new Error('Method not implemented.');
    }
    async updateFile(resource, changes, opts) {
        await this.initialized;
        throw new Error('Method not implemented.');
    }
    toFilePath(resource) {
        return (0, path_1.normalize)(resource.path.toString());
    }
    toType(entry, symbolicLink) {
        // Signal file type by checking for file / directory, except:
        // - symbolic links pointing to non-existing files are FileType.Unknown
        // - files that are neither file nor directory are FileType.Unknown
        let type;
        if (symbolicLink === null || symbolicLink === void 0 ? void 0 : symbolicLink.dangling) {
            type = files_1.FileType.Unknown;
        }
        else if (entry.isFile()) {
            type = files_1.FileType.File;
        }
        else if (entry.isDirectory()) {
            type = files_1.FileType.Directory;
        }
        else {
            type = files_1.FileType.Unknown;
        }
        // Always signal symbolic link as file type additionally
        if (symbolicLink) {
            type |= files_1.FileType.SymbolicLink;
        }
        return type;
    }
    // FIXME typing
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    promisify(f) {
        // eslint-disable-next-line @typescript-eslint/tslint/config, @typescript-eslint/no-explicit-any
        return function (...args) {
            return new Promise((resolve, reject) => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                f(...args, (err, result) => err ? reject(err) : resolve(result));
            });
        };
    }
    toFileSystemProviderError(error) {
        if (error instanceof files_1.FileSystemProviderError) {
            return error; // avoid double conversion
        }
        let code;
        switch (error.code) {
            case 'ENOENT':
                code = files_1.FileSystemProviderErrorCode.FileNotFound;
                break;
            case 'EISDIR':
                code = files_1.FileSystemProviderErrorCode.FileIsADirectory;
                break;
            case 'ENOTDIR':
                code = files_1.FileSystemProviderErrorCode.FileNotADirectory;
                break;
            case 'EEXIST':
                code = files_1.FileSystemProviderErrorCode.FileExists;
                break;
            case 'EPERM':
            case 'EACCES':
                code = files_1.FileSystemProviderErrorCode.NoPermissions;
                break;
            default:
                code = files_1.FileSystemProviderErrorCode.Unknown;
        }
        return (0, files_1.createFileSystemProviderError)(error, code);
    }
};
BrowserFSFileSystemProvider = (0, tslib_1.__decorate)([
    (0, inversify_1.injectable)(),
    (0, tslib_1.__param)(0, (0, inversify_1.inject)(browserfs_filesystem_initialization_1.BrowserFSInitialization)),
    (0, tslib_1.__metadata)("design:paramtypes", [Object])
], BrowserFSFileSystemProvider);
exports.BrowserFSFileSystemProvider = BrowserFSFileSystemProvider;
//# sourceMappingURL=browserfs-filesystem-provider.js.map