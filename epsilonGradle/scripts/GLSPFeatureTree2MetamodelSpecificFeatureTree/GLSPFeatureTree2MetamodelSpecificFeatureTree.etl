pre {
	var metamodelelements = metamodel!EClassifier.all.select(c|not c.abstract).collect(c|c.name);
	//var metamodelName = ecoreModel!EPackage.all.first.name.println();
	var nodes = viewpointModel!Node.all.collect(n|n.name);
	var edges = viewpointModel!Edge.all.collect(e|e.name);
	
	//var root = new t_featureModel;
	//metamodelSpecificFeatureTree.root = new t_featureModel; //root;
}

rule FeatureModel
	transform s : glspFeatureTree!t_featureModel
	to t : metamodelSpecificFeatureTree!t_featureModel {
	
		("Start transforming GLSPFeatureTree into a metamodel specific feature tree!").println();
		
		//metamodelSpecificFeatureTree!root = t;
		//metamodelSpecificFeatureTree.root = root;
		metamodelSpecificFeatureTree.root = t;
		
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
			//root.appendChild(c.equivalent());
		}
		
		"Transformation finished!".println();
		
}

@lazy
rule Properties
	transform s : glspFeatureTree!t_properties
	to t : metamodelSpecificFeatureTree!t_properties {
		
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
		}
	
}

@lazy
rule Struct
	transform s : glspFeatureTree!t_struct
	to t : metamodelSpecificFeatureTree!t_struct {
	
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
		}
	
}

@lazy
rule Constraints
	transform s : glspFeatureTree!t_constraints
	to t : metamodelSpecificFeatureTree!t_constraints {
	
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
		}
	
}

@lazy
rule Graphics
	transform s : glspFeatureTree!t_graphics
	to t : metamodelSpecificFeatureTree!t_graphics {
	
		t.a_key = s.a_key;
		t.a_value = s.a_value;
	
}

@lazy
rule And
	transform s : glspFeatureTree!t_and
	to t : metamodelSpecificFeatureTree!t_and {
	
		t.a_abstract = s.a_abstract;
		t.a_mandatory = s.a_mandatory;
		t.a_name = s.a_name;
		t.a_hidden = s.a_hidden;
		
		for (c in s.children) {
			if (c.isTypeOf(glspFeatureTree!t_feature)){
				t.processAndFeature(c);
			} else {
				t.appendChild(c.equivalent());
			}
		}
	
}

@lazy
rule Alt
	transform s : glspFeatureTree!t_alt
	to t : metamodelSpecificFeatureTree!t_alt {
	
		t.a_abstract = s.a_abstract;
		t.a_mandatory = s.a_mandatory;
		t.a_name = s.a_name;
		t.a_hidden = s.a_hidden;
		
		for (c in s.children) {
			if (c.isTypeOf(glspFeatureTree!t_feature)){
				t.processAltFeature(c);
			} else {
				t.appendChild(c.equivalent());
			}
		}
	
}

@lazy
rule Feature
	transform s : glspFeatureTree!t_feature
	to t : metamodelSpecificFeatureTree!t_feature {
	
		t.a_abstract = s.a_abstract;
		t.a_mandatory = s.a_mandatory;
		t.a_name = s.a_name;
		t.a_hidden = s.a_hidden;
	
}

@lazy
rule Rule
	transform s : glspFeatureTree!t_rule
	to t : metamodelSpecificFeatureTree!t_rule {
	
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
		}
		
}

@lazy
rule Eq
	transform s : glspFeatureTree!t_eq
	to t : metamodelSpecificFeatureTree!t_eq {
	
		for (c in s.children) {
			//c.equivalent().println();
			t.appendChild(c.equivalent());
		}
		
}

@lazy
rule Var
	transform s : glspFeatureTree!t_var
	to t : metamodelSpecificFeatureTree!t_var {
	
		t.text = s.text;
		
}

function metamodelSpecificFeatureTree!t_and processAndFeature(oldFeature : glspFeatureTree!t_feature){

	if (oldFeature.a_name.startsWith("E_")) {
		for (e in nodes) { //metamodelelements
			var feature = new metamodelSpecificFeatureTree!t_feature;
			feature.a_abstract = oldFeature.a_abstract;
			feature.a_mandatory = oldFeature.a_mandatory;
			feature.a_name = oldFeature.a_name.replaceFirst("E", "N") + "_" + e;
			feature.a_hidden = oldFeature.a_hidden;
			self.appendChild(feature);
		}
		for (e in edges) { //metamodelelements
			var feature = new metamodelSpecificFeatureTree!t_feature;
			feature.a_abstract = oldFeature.a_abstract;
			feature.a_mandatory = oldFeature.a_mandatory;
			feature.a_name = oldFeature.a_name + "_" + e;
			feature.a_hidden = oldFeature.a_hidden;
			self.appendChild(feature);
		}
	} else {
		self.appendChild(oldFeature.equivalent());
	}

}

function metamodelSpecificFeatureTree!t_alt processAltFeature(oldFeature : glspFeatureTree!t_feature){

	if (oldFeature.a_name.startsWith("E_")) {
		for (e in nodes) { //metamodelelements
			var feature = new metamodelSpecificFeatureTree!t_feature;
			feature.a_abstract = oldFeature.a_abstract;
			feature.a_mandatory = oldFeature.a_mandatory;
			feature.a_name = oldFeature.a_name.replaceFirst("E", "N") + "_" + e;
			feature.a_hidden = oldFeature.a_hidden;
			self.appendChild(feature);
		}
		for (e in edges) { //metamodelelements
			var feature = new metamodelSpecificFeatureTree!t_feature;
			feature.a_abstract = oldFeature.a_abstract;
			feature.a_mandatory = oldFeature.a_mandatory;
			feature.a_name = oldFeature.a_name + "_" + e;
			feature.a_hidden = oldFeature.a_hidden;
			self.appendChild(feature);
		}
	} else {
		self.appendChild(oldFeature.equivalent());
	}

}
