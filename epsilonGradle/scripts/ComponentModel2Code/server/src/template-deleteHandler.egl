[%import "../../metamodel_utils.eol";%]
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
package [%=_packageName%].handler;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CompoundCommand;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.edit.command.RemoveCommand;
import org.eclipse.emf.edit.command.SetCommand;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.glsp.server.emf.EMFOperationHandler;
import org.eclipse.glsp.server.emf.model.notation.NotationElement;
import org.eclipse.glsp.server.emf.notation.EMFNotationModelState;
import org.eclipse.glsp.server.emf.EMFIdGenerator;
import org.eclipse.glsp.server.emf.model.notation.NotationElement;
import org.eclipse.glsp.server.emf.model.notation.Shape;
import org.eclipse.glsp.server.operations.DeleteOperation;
import [%=_metamodelPackageName%].[%=_metamodelName.toLowerCase()%].[%=_metamodelName.firstToUpperCase()%]Package;
[%for ( n in _nodes){%]
import [%=_metamodelPackageName%].[%=_metamodelName.toLowerCase()%].[%=n%];
[%}%]
[%for ( e in _edges){%]
import [%=_metamodelPackageName%].[%=_metamodelName.toLowerCase()%].[%=e%];
[%}%]
import [%=_metamodelPackageName%].[%=_metamodelName.toLowerCase()%].[%=_root%];

import com.google.inject.Inject;

public class DeleteHandler extends EMFOperationHandler<DeleteOperation> {

   @Inject
   protected EMFNotationModelState modelState;
   
   @Inject
   protected EMFIdGenerator idGenerator;
   
   protected Set<String> alreadyDeletedEdges;

   @Override
   public Optional<Command> createCommand(final DeleteOperation operation) {
      if (!constraintSatisfied()) return Optional.empty();
   
      List<String> elementIds = operation.getElementIds();
      if (elementIds == null || elementIds.size() == 0) {
         System.err.println("[DeleteNodeHandler] Elements to delete are not specified: elementIds = " + elementIds);
         return Optional.empty();
      }
      
      List<Command> commands = createDeleteCommands(elementIds);
      if (commands.isEmpty()) {
          System.err.println("[DeleteNodeHandler] No commands created for the specified elements.");
      }
      
      return commands.isEmpty() ? Optional.empty() : Optional.of(new CompoundCommand(commands));
   }

   private List<Command> createDeleteCommands(final List<String> elementIds) {
      alreadyDeletedEdges = new HashSet<>();
      
      List<Command> commands = new ArrayList<>();
      for (String elementId : elementIds) {
         Optional<EObject> semanticElement = modelState.getSemanticModel().eContents().stream()
                 .map(obj -> (EObject) obj)
                 .filter(obj -> idGenerator.getOrCreateId(obj).equals(elementId))
                 .findFirst();

         Optional<NotationElement> notationElement = modelState.getNotationModel().eContents().stream()
                 .filter(obj -> obj instanceof Shape)
                 .map(obj -> (NotationElement) obj)
                 .filter(obj -> idGenerator.getOrCreateId(obj).equals(elementId))
                 .findFirst();
                 
         if (semanticElement.isEmpty()) {
             System.err.println("[DeleteNodeHandler] Could not find semantic element for ID: " + elementId);   
         }
         semanticElement.map(this::createDependentRemoveCommand).ifPresent(commands::addAll);
         notationElement.map(this::createDependentRemoveCommand).ifPresent(commands::addAll);
      }
      return commands;
   }

   private List<Command> createDependentRemoveCommand(final EObject element) {
	  EObject semanticModel = modelState.getSemanticModel();
	  [%=_root%] [%=_root.firstToLowerCase()%] = [%=_root%].class.cast(semanticModel);
      EditingDomain editingDomain = modelState.getEditingDomain();
      List<Command> commands = new ArrayList<>();
      
      [%for ( n in _nodes){%]
      if (element instanceof [%=n%] [%=n.firstToLowerCase()%]) {
    	  String [%=n.firstToLowerCase()%]Id = idGenerator.getOrCreateId([%=n.firstToLowerCase()%]);
          //System.err.println("Processing [%=n%] with ID: " + [%=n.firstToLowerCase()%]Id);
    	  
    	  [%for ( e in _edges){%]
          [%=_root.firstToLowerCase()%].get[%=getReferenceName(e, _root).firstToUpperCase()%]().stream()
          .filter(edge -> edge.get[%=getSourceReference(e).firstToUpperCase()%]() == [%=n.firstToLowerCase()%] || edge.get[%=getTargetReference(e).firstToUpperCase()%]() == [%=n.firstToLowerCase()%])
          .collect(Collectors.toList())
    	  .forEach(
          edge -> {
              //System.err.println("Removing [%=e%] with ID(" + idGenerator.getOrCreateId(edge) + ") connected to [%=n%] ID: " + [%=n.firstToLowerCase()%]Id);
              commands.addAll(createRemoveEdgeCommand(edge));
          });
          
    	  //state.getOutArcs().forEach(arc -> commands.addAll(createRemoveEdgeCommand(arc)));
          //state.getInArcs().forEach(arc -> commands.addAll(createRemoveEdgeCommand(arc)));
          
          [%}%]
          
          commands.add(
          [%if (getUpperBound(n, _root).isDefined() and getUpperBound(n, _root) == 1){%]
              SetCommand.create(editingDomain, element.eContainer(), element.eContainingFeature(), SetCommand.UNSET_VALUE)
          [%}else{%]
              RemoveCommand.create(editingDomain, element.eContainer(), element.eContainingFeature(), element)
          [%}%]
          );
          return commands;
      }
      
      [%}%]
      
      [%for ( e in _edges){%]
      if (element instanceof [%=e%] [%=e.firstToLowerCase()%]) {
    	  //String [%=e.firstToLowerCase()%]Id = idGenerator.getOrCreateId([%=e.firstToLowerCase()%]);
          //System.err.println("Processing [%=e%] with ID: " + [%=e.firstToLowerCase()%]Id);
    	  
          commands.addAll(createRemoveEdgeCommand([%=e.firstToLowerCase()%]));
          return commands;
      }
      
      [%}%]

      commands.add(
              RemoveCommand.create(editingDomain, element.eContainer(), element.eContainingFeature(), element)
      );
      return commands;
   }
   
   [%for ( e in _edges){%]
   protected List<Command> createRemoveEdgeCommand([%=e%] [%=e.firstToLowerCase()%]){
	      EditingDomain editingDomain = modelState.getEditingDomain();
	      List<Command> commands = new ArrayList<>();

	      String [%=e.firstToLowerCase()%]Id = idGenerator.getOrCreateId([%=e.firstToLowerCase()%]);
	      
	      // prevents duplicate remove commands for arcs since they can also be removed as a consequence
	      // of removing their source/target node
	      if (alreadyDeletedEdges.contains([%=e.firstToLowerCase()%]Id)) {
	    	 System.err.println("createRemoveEdgeCommand - [%=e%] already deleted: " + [%=e.firstToLowerCase()%]Id);
	         return commands;
	      }

	      alreadyDeletedEdges.add(idGenerator.getOrCreateId([%=e.firstToLowerCase()%]));

	      
//	      commands.add(
//	          RemoveCommand.create(editingDomain, transition,
//	        		  StatemachinePackage.Literals.TRANSITION__FROM, transition.getFrom())
//	      );
//	      commands.add(
//	          RemoveCommand.create(editingDomain, transition,
//	        		  StatemachinePackage.Literals.TRANSITION__TO, transition.getTo())
//	      );
	      commands.add(
	          RemoveCommand.create(editingDomain, [%=e.firstToLowerCase()%].eContainer(), [%=e.firstToLowerCase()%].eContainingFeature(), [%=e.firstToLowerCase()%])
	      );

	      return commands;
	   }

   [%}%]
	   
   protected boolean constraintSatisfied() {
	   // USER INSERTS CONSTRAINT FOR DELETION HERE
	   
	   return true;
   }

}